---
title: "浏览器(二)"
tags: TeXt
---

# 浏览器（二）

### 从地址栏中输入url后，浏览器会发生什么事？

（1）浏览器的主进程的UI线程判断输入的是不是url，如果是url，就通知网络进程进行发送请求。

（2）网络进程得到数据之后，交给主进程中的UI线程。UI线程将数据包装好后交给任务队列。渲染进程通知渲染引擎进行处理。

#### 什么是浏览器的渲染？

HTML字符串--->渲染--->像素信息（绘制指令）

如下图：

![]({{site.url}}/assets/blogImages/blog016/16-1.png)

渲染引擎首先拿到了HTML字符串文本，并对它进行解析，生成有用的像素信息。

### HTML的解析对不同的元素会有不同的表现，HTML字符串的解析主要会遇到哪些标签？

渲染引擎拿到的是HTML文本，CSS文本和JS文本都可以通过网络请求下载到HTML文本中。所以HTML文本会遇到三种标签:元素标签、CSS标签、JS。

（1）首先渲染引擎拿到HTML标签之后，会生成一个document对象，然后根据HTML文本文件生成一个DOM树。

（2）遇到CSS标签，会另外开辟一个线程处理CSS的解析。所以CSS的下载和解析不会阻塞HTML的解析，但会影响元素的渲染。经过CSS的解析后，会生成一棵CSSOM树。

（3）当遇到内部JS或者遇到外部的JS的时候，他会阻塞标签的解析。当解析HTML标签的途中遇到外部JS，必须等待外部的JS下载完毕，并且解析完毕之后，才会进行后续的HTML的解析。

由于DOM树是由渲染引擎生成的对象组合而成的数，所以它的对象是一个C++对象，为了使得JS能偶访问，将C++对象树进行了包装。同理CSSOM树也会经过包装才能被JS访问。

然后通过样式的计算：通过CSSOM和DOM生成含有所有DOM的DOM树。

### 生成Layout树

通过计算每个元素的像素值，生成Layout树。由于不是所有的元素都会再页面中显示，所以,Layout树可能会比真正的DOM树少一些元素。少的元素:display:none的元素、head元素等。并且还有遵守一定的规则：文本必须在行盒中，如果没有行盒，则会生成一个匿名行盒；行盒不能与块盒子相邻。否则也会生成匿名块盒

### 分层

为什么要分层？因为有些元素会不断地改变，如果放在同一层，则会不断引起元素的回流与重绘。

### 绘制

根据布局树生成每一层的指令集，当由元素需要发生变化的时候，修改对应一层的指令集即可。绘制指令犹如：把画笔移动到...坐标，放下画笔，绘制一条直线...。在渲染进程的主线程中生程了各层的绘制指令后，就将绘制指令交给渲染进程的合成线程。

如下图：

![]({{site.url}}/assets/blogImages/blog016/16-2.png)

### 分块

合成线程对网页进行分块，分块的目的是确定哪些块接近视口并进行渲染。合成线程会启动多个线程来进行分块的处理。这些线程会交给一个线程池进行管理。为什么要交给线程池进行管理？因为线程池中的线程数量是有限的，不能生成无线多个线程进行分块。在处理分块的时候，只是从线程池里拿出几个线程进行处理。如下图：

![]({{site.url}}/assets/blogImages/blog016/16-3.png)

### 光栅化

采用GPU进程进行光栅化，GPU进程也是开启了多个线程进行光栅化的处理。光栅化产生位图，位图就是每一个像素具体的颜色信息，并将位图交给合成线程进行处理。

![]({{site.url}}/assets/blogImages/blog016/16-4.png)

### 绘制

将位图与具体的屏幕相结合，确定每一个像素在屏幕的具体位置。并将信息转给GPU进程，GPU进程再将信息转给硬件（显卡）进行显示。

![]({{site.url}}/assets/blogImages/blog016/16-5.png)

总结：

![]({{site.url}}/assets/blogImages/blog016/16-6.png)

在浏览器中，当我们改变某个元素的大小或者位置的时候，我们的浏览器会发生回流。所以考虑到一个网页在频发改变元素的几何信息的时候，浏览器会频繁地触发回流。所以，会将所有改变元素的几何信息进行异步处理。这时又出现了问题：如果要读取元素的信息，那么读取的元素信息就不准确，所以在读取元素信息的时候（clientHeight），进行强制的回流。

## 思考以下问题：

1、什么是回流？

回流本质是重新生成一个布局树（渲染树），所以生成渲染树之后的步骤都会重新进行。所以会影响到渲染进程中的主线程。

2、什么是重绘？

重绘的本质就是根据分层的信息重新计算绘制指令。

3、为什么transform的效率更高？

因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段。由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。





